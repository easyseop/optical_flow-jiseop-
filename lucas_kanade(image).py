# -*- coding: utf-8 -*-
"""Lucas Kanade(Image).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ofou-mkcTO28o8qSO6GEgFB-gIkb9pgr
"""

##https://github.com/khushboo-agarwal/Optical-Flow/blob/master/PA2_1.py

from google.colab import drive
drive.mount('/content/drive')

b1_path = '/content/drive/MyDrive/Optical Flow/b1.png'
b2_path = '/content/drive/MyDrive/Optical Flow/b2.png'
c1_path = '/content/drive/MyDrive/Optical Flow/p1.jpeg'
c2_path = '/content/drive/MyDrive/Optical Flow/p2.jpeg'



"""#Lucas Kanade(main)

"""

#import libraries
import math
from scipy import signal
from PIL import Image
import numpy as np
from numpy import *
from matplotlib import pyplot as plt
from pylab import *
import cv2
import random

lis = None
def LK_OpticalFlow(Image1,Image2):
  
  I1 = np.array(Image1)
  I2 = np.array(Image2)
  S = np.shape(I1) # 사진의 크기 또는 사이즈 ex) 640*480


  
	#applying Gaussian filter of size 3x3 to eliminate any noise
  I1_smooth = cv2.GaussianBlur(I1 #input image
								,(3,3)	#shape of the kernel
								,0      #lambda
								)
  I2_smooth = cv2.GaussianBlur(I2, (3,3), 0) 
  # -> 이미지 연산 속도 증가 및 노이즈 제거 

	
	# First Derivative in X direction
  Ix = signal.convolve2d(I1_smooth,[[-0.25,0.25],[-0.25,0.25]],'same') + signal.convolve2d(I2_smooth,[[-0.25,0.25],[-0.25,0.25]],'same') # 연산을 편하게하고 노이즈를 제거한 후 이미지를 합치는 과정 
	# First Derivative in Y direction
  Iy = signal.convolve2d(I1_smooth,[[-0.25,-0.25],[0.25,0.25]],'same') + signal.convolve2d(I2_smooth,[[-0.25,-0.25],[0.25,0.25]],'same')
	# First Derivative in XY direction
  It = signal.convolve2d(I1_smooth,[[0.25,0.25],[0.25,0.25]],'same') + signal.convolve2d(I2_smooth,[[-0.25,-0.25],[-0.25,-0.25]],'same')
	
	# finding the good features
  features = cv2.goodFeaturesToTrack(I1_smooth # Input image
	,10000 # max corners : 크게 수정할 수록 많은 점을 찾음 
	,0.01 # lambda 1 (quality)
	,10 # lambda 2 (quality)
	)	

  feature = np.int0(features) 
  plt.figure(figsize=(20,20))
  plt.subplot(1,3,1)
  plt.title('Frame 1')
  plt.imshow(I1_smooth, cmap = cm.gray)
  plt.subplot(1,3,2)
  plt.title('Frame 2')
  plt.imshow(I2_smooth, cmap = cm.gray)#plotting the features in frame1 and plotting over the same
  for i in feature:
    x,y = i.ravel()
    cv2.circle(I1_smooth #input image
      ,(x,y) 			 #centre
      ,3 				 #radius
      ,0 			 #color of the circle
      ,-1 			 #thickness of the outline
      ) # image1에 점의 위치를 circle로 나타낸다 . 

  #creating the u and v vector
  u = v = np.nan*np.ones(S)

  # Calculating the u and v arrays for the good features obtained n the previous step.
  for l in feature:
    j,i = l.ravel()
    
    # calculating the derivatives for the neighbouring pixels
    # since we are using  a 3*3 window, we have 9 elements for each derivative.
    
    IX = ([Ix[i-1,j-1],Ix[i,j-1],Ix[i-1,j-1],Ix[i-1,j],Ix[i,j],Ix[i+1,j],Ix[i-1,j+1],Ix[i,j+1],Ix[i+1,j-1]]) #The x-component of the gradient vector
    IY = ([Iy[i-1,j-1],Iy[i,j-1],Iy[i-1,j-1],Iy[i-1,j],Iy[i,j],Iy[i+1,j],Iy[i-1,j+1],Iy[i,j+1],Iy[i+1,j-1]]) #The Y-component of the gradient vector
    IT = ([It[i-1,j-1],It[i,j-1],It[i-1,j-1],It[i-1,j],It[i,j],It[i+1,j],It[i-1,j+1],It[i,j+1],It[i+1,j-1]]) #The XY-component of the gradient vector
    
    # Using the minimum least squares solution approach
    LK = (IX, IY)
    LK = np.matrix(LK)
    LK_T = np.array(np.matrix(LK)) # transpose of A
    LK = np.array(np.matrix.transpose(LK)) 
   
    
    A1 = np.dot(LK_T,LK) #Psedudo Inverse
    A2 = np.linalg.pinv(A1)
    A3 = np.dot(A2,LK_T)
    
    (u[i,j],v[i,j]) = np.dot(A3,IT) # we have the vectors with minimized square error
  

  #======= Pick Random color for vector plot========
  colors = "bgrcmykw"
  color_index = random.randrange(0,8)
  c=colors[color_index]
  #======= Plotting the vectors on the image========
  plt.figure(figsize=(44,20))
  plt.subplot(1,3,3)
  plt.title('Vector plot of Optical Flow of good features')
  plt.imshow(I1,cmap = cm.gray)
  for i in range(S[0]):
    for j in range(S[1]):
      if abs(u[i,j])>t or abs(v[i,j])>t: # setting the threshold to plot the vectors
        # print(j,i,v[i,j],u[i,j])
        plt.scatter(j,i,color =c)
        plt.arrow(j,i,v[i,j],u[i,j],head_width = 5, head_length = 5, color = c)
        
  plt.show()

t = 5 # choose threshold value : t가 클수록 변화량이 큰 값들만 표시 
#import the images
Image1 = Image.open(b1_path).convert('L')  
Image2 = Image.open(b2_path).convert('L')
LK_OpticalFlow(Image1, Image2)

Image3 = Image.open(c1_path).convert('L')
Image4 = Image.open(c2_path).convert('L')

Image3 = Image3.resize((256, 256))
Image4 = Image4.resize((256, 256)) # 비교하는 이미지의 크기가 같아야 하므로 resizing
LK_OpticalFlow(Image3, Image4)
# Image5 = Image.open('teddy1.png').convert('L')
# Image6 = Image.open('teddy2.png').convert('L')
# LK_OpticalFlow(Image5, Image6)